### 1、const 的理解
const 是C语言的一个关键字，需要注意的是，const 关键字是把变量变为一个只读的变量（也就是不可以作为左值），绝对不是将这个变量变为常量。也就是说经过const 修饰的变量成为只读的变量之后，那么这个变量就只能作为右值（只能赋值给别人），绝对不能成为左值（不能接收别人的赋值）。

而 C++ 则是将 const 修饰的常量变为一个真正的常量（变量的内容不可以被修改）， 这一点的区别需要进行注意。当 const 变量的时候，就将这个常量放在符号表里面，编译的过程中发现使用了变量，那么就从符号表里面的值进行替换。

指针和const，主要有两种情况，一是指针p的值是否可修改，二是指针对应的\*p值是否可修改（仅指是否能通过\*p修改，不涉及通过原变量修改）

经过const 修饰的变量，在定义的时候，就要进行初始化。

```c
const int a = 10;  // 正确

const int a;  // 错误
```

`const` 关键字最有用的地方是用来限定函数的形参
```c
func(const char *ptr)
{
}
```
这样 ，func 函数将不会修改实参指针所指的数据，但是其他的函数却可以修改他。

const 本质上被命名为 readonly 更为合适。


### 2、指向const的指针
首先，是一个指针，但是这个指针是指向一个const 类型的指针。 

一般：

```c
const int *p  // 一般使用这个
//或者
int const *p
```
或者：
第一种：首先 P 是一个指针，P所指向的内容（*P）所指向的内容是 const int 类型的。

第二种，: 首先 P 也是一个指针，指向的内容是 const int 类型的，也就是所指向的内容是是绝对不能被修改的。

两种情况下，原变量可修改，p可修改，但是*p不能修改。


### 3、const 指针
首先是一个指针，只不过这个指针是 const 类型的，也就是这个指针变量的地址，只能在初始化之后，就一直指向这个地址，地址所被保存的内容是可变的。 

`int * const p = 地址 // 因为P 所指向的地址是不能被修改的，所以必须被初始化`
首先，这个P 是一个指针，而这个指针是指向了 int 类型的 const 指针。只不过地址是被固定，不能改变，但是地址所保存的数值确实可变的，比如：

`*p = 3;`
原变量可修改，*p可修改，但是p不可修改。
### 4、指针和内容都是不可变的

顾名思义，就是指针的地址和地址所被保存的内容都是不可变的。 
```c
const int * const p = 地址值
int const * const p = 地址值
```
可见 P 是一个指针，但是这个指针，前面有 const 进行修饰，所以，这个 P 指针就是一个指针常量，所以 P 的地址就被固定了，所以只能进行初始化了。 而对于 \*p 而言，前面又有 const 进行修饰，所以\*p 就是一个常量了，也就是 p 指向地址，地址上保存的数据是一个常量，不能被改变的。

原变量可修改，*p和p都不可修改。
### 5、理解记忆
其实就看 const 的位置。const，在指针的星号之前，那么就是指向const 的指针，也就是 \*p 的内容是常量，不能被改变。 

const 在星号之后的话，那么 ，就是指向 const 的指针，也就是这个指针指向的地址，不能被改变的，所以，const 指针就必须进行初始化，然后这个地址就是一直被固定住了，不能内改变的。

### 6. 细节
```c
int main()
{
	const int a=10;
	int *b = &a;
	*b = 12;
	printf("%d\n", *b);
}
//输出12

```
从这里可以看出a的值被修改了,在C语言中用const去修饰整形变量a，即a的值是不可变的，不能显示地通过赋值语句去改变a的值，
但是不代表在程序中不能通过其它方法来修改这个值。

总结:
(1)在C语言中用const去修饰一个变量，表示这个变量是只读的，不可通过显式的调用a去修改a的值(但是可以用其他指针去修改)，并且此时a仍然是一个变量，不能等同于常量;
(2)要注意const在声明变量时所处的位置，位置不同，在意义上可能会有很大的不同。
如果const在'*'左边，则表示指针指向的变量的值不可变;
如果const在'*'右边，则表示指针的值是不可变的;

### 7、const 与 define 区别

const 是由编译器进行处理，执行类型检查和作用域的检查；

define 是由预处理器进行处理，只做简单的文本替换工作而已。