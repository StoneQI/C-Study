### 指针和指针变量

注：内存地址0-255是系统保留内存，不能读也不能写。

- 内存区的每一个字节都有一个编号，这就是“地址”。
- 如果在程序中定义了一个变量，在对程序进行编译或运行时，系统就会给这个变量分配内存单元，并确定它的内存地址(编号)
- 指针的实质就是内存“地址”。指针就是地址，地址就是指针。
- 指针是内存单元的编号，指针变量是存放地址的变量。
- 通常我们叙述时会把指针变量简称为指针，实际他们含义并不一样。
- 指针变量也有地址。

### 野指针和空指针
指针变量也是变量，是变量就可以任意赋值，不要越界即可（32位为4字节，64位为8字节），但是，任意数值赋值给指针变量没有意义，因为这样的指针就成了野指针，此指针指向的区域是未知(操作系统不允许操作此指针指向的内存区域)。所以，野指针不会直接引发错误，操作野指针指向的内存区域才会出问题。

但是，野指针和有效指针变量保存的都是数值，为了标志此指针变量没有指向任何变量(空闲可用)，C语言中，可以把NULL赋值给此指针，这样就标志此指针为空指针，没有任何指针。
```c
int *p = NULL;
\\NULL是一个值为0的宏常量：
#define NULL    ((void *)0)
```
### 万能指针
void *指针可以指向任意变量的内存空间：
```c
void *p = NULL;

int a = 10;
p = (void *)&a; //指向变量时，最好转换为void *

//使用指针变量指向的内存时，转换为int *
*( (int *)p ) = 11;
printf("a = %d\n", a);

```

### const修饰指针变量
```c
int a = 100;
int b = 200;

//指向常量的指针
//修饰*，指针指向内存区域不能修改，指针指向可以变
const int *p1 = &a; //等价于int const *p1 = &a;
//*p1 = 111; //err
p1 = &b; //ok

//指针常量
//修饰p1，指针指向不能变，指针指向的内存可以修改
int * const p2 = &a;
//p2 = &b; //err
*p2 = 222; //ok

```
### 指针和数组

```c
int arr[10]={0};
int* p=arr;

//p[i] 和*(p+i)都能访问数组
```
任何方式访问数组，可能会出现数组下标访问越界。

### 指针和函数
1. 所有函数都使用值传递：其实即使是指针，也是值传递。C++中引用传递归结到最后仍然是值传递

2. 实参到形参的参数传递过程其实是形参的初始化(!=赋值)过程。传递参数时做一些运算表达式，直接按赋值初始化理解

3. 形参的作用域是函数域，它和函数内定义的其他自动变量一样，并没有任何特殊性。

4. 函数形式参数带const限定符时，实参是可以成功传递的，这次传递相当于初始化。一旦初始化后，即不允许改变

5. 参数传递的顺序是从右到左。

6. 数组名做函数参数，函数的形参会退化为指针。

### *和++
1. *和++属于同级运算符，从右往左执行
2. *p++.先对原p取值，输出\*p，在进行++
3. ++*P，先对原p取值，在对\*p进行++
4. *++p,为*(++p),先p加一，在进行取值
