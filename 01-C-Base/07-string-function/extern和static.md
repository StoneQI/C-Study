### (1)修饰局部变量
a.一般情况下，对于局部变量是存放在栈区的，并且局部变量的生命周期在该语句块执行结束时便结束了。但是如果用static进行修饰的话，该变量便存放在静态数据区，其生命周期一直持续到整个程序执行结束； 
b.对静态局部变量是在编译时赋初值的，即只赋初值一次，在程序运行时它已有初值。以后每次调用函数时不再重新赋初值而是保留上次函数调用结束时的值； 
c.如果在定义局部变量时不赋初值的话，对静态局部变量来说，编译时自动赋初值0（对数值型变量）或'\0'字符（对字符变量）。而对自动变量来说如果不赋初值则它的值是一个不确定的值； 
d.虽然静态局部变量在函数调用结束后仍然存在，但其他函数不能引用它。

什么情况下需要用局部静态变量呢？
a.需要保留函数上一次调用结束时的值； 
eg:

```c
#include<stdio.h>  
void fun()  
{   
static int a=1; a++;   
printf("%d\n",a);  
}  
int main(void)  
{   
fun();   
fun();   
return 0;  
}
```


程序执行结果为: 2 3 
说明在第二次调用fun()函数时，a的值为2，并且没有进行初始化赋值，直接进行自增运算，所以得到的结果为3. 
b.如果初始化后，变量只引用而不改变其值，则这时用静态局部变量比较方便，以免每次调用时重新赋值

##＃　(2)修饰全局变量
static修饰全局变量只能在本文件中使用。如果一个全局变量，它既可以在本源文件中被访问到，也可以在同一个工程的其它源文件中被访问就需要用到extern.

eg:
```c
file1.c  
int a=1;

file2.c
#include
extern int a;  
int main(void)  
{  
printf("%d\",a);  
retu
则执行结果为 1

但是如果在file1.c中把int a=1改为static int a=1;

那么在file2.c是无法访问到变量a的。原因在于用static对全局变量进行修饰其作用域仅局限于本文件。

### (3)内部函数和外部函数
用static修饰函数称为静态函数（也叫内部函数），对函数的作用域仅局限于本文件。这样不同的人编写不同的函数时不用担心自己定义的函数是否会与其它文件中的函数同名，因为同名也没关系 
eg:
```c
a.c
static int i;//只在a.c中可用
int j;//工程里用
static int funA() //只在a.c中可用
{
}
int funB()//工程里用
{
}
```
用extern修饰函数称为外部函数，可供其他文件调用。函数首部可以写为
```c
extern int fun(int a,int b)
```