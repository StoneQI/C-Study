

### 算术转换
进行算术运算（加、减、乘、除、取余以及符号运算）时，不同类型数招必须转换成同一类型的数据才能运算，算术转换原则为：
在进行运算时，以表达式中最长类型为主，将其他类型位据均转换成该类型，如：
(1)若运算数中有double型或float型，则其他类型数据均转换成double类型进行运算。
(2)若运算数中最长的类型为long型．则其他类型数均转换成long型数。
(3)若运算数中最长类型为int型，则char型也转换成int型进行运算。算术转换是在运算过程中自动完成的。

### 赋值转换
进行赋值操作时，赋值运算符右边的数据类型必须转换成赋值号左边的类型，若右边的数据类型的长度大于左边，则要进行截断或舍入操作。
下面用一实例说明：
      char ch;
      int i,result;
      float f;
      double d;
      result=ch/i+(f*d-i);
(1)首先计算 ch/i,ch → int型，ch/i → int型。
(2)接着计算 f*d-i，由于最长型为double型，故f→double型，i→double型，f*d-i→double型。
(3)(ch/i) 和(f*d-i)进行加运算，由于f*d-i为double型，故ch/i→double型，ch/i+(f*d-i)→double型。
(4)由于result为int型，故ch/i+(f*d-i)→double→int，即进行截断与舍入，最后取值为整型。

### 输出转换
在程序中将数据用printf函数以指定格式输出时，当要输出的盐据类型与输出格式不符时，便自动进行类型转换，如一个long型数据用整型格式(%d)输出时，则相当于将long型转换成整型(int)数据输出；一个字符(char）型数据用整型格式输出时，相当于将char型转换成int型输出。
注意：较长型数据转换成短型数据输出时，其值不能超出短型数据允许的值范围，否则转换时将出错。如：
      long a=80000;
      printf("%d",a);
运行结果为14464，因为int型允许的最大值为32767，80000超出此值，故结果取以32768为模的余数，即进行如下取余运算：
      (80000-32768)-32768=14464;
输出的数据类型与输出格式不符时常常发生错误，如：
      int d=9;
      printf("%f",d);
或
      float c=3.2;
      printf("%d",c);
将产生错误的结果。

### 常见规则
运算符左右类型不匹配时，会对其中一个做自动类型转换：

int     ---> long
int8,char,short   ----> int 
int     ----> uint  
float  ----> double 

1. 在表达式中，char 和 short 类型的值，无论有符号还是无符号，都会自动转换成 int 或者 unsignedint（如果 short 的大小和 int 一样，unsigned short 的表示范围就大于 int，在这种情况下，unsignedshort 被转换成 unsigned int）。因为它们被转换成表示范围更大的类型，故而把这种转换称为“升级（promotion）”。

2. 按照从高到低的顺序给各种数据类型分等级，依次为：long double, double, float, unsignedlong long, long long, unsigned long, long, unsigned int 和int。这里有一个小小的例外，如果 long 和 int 大小相同，则 unsigned int 的等级应位于 long 之上。char 和short 并没有出现于这个等级列表，是因为它们应该已经被升级成了 int 或者 unsigned int。

3. 在任何涉及两种数据类型的操作中，它们之间等级较低的类型会被转换成等级较高的类型。

4. 在赋值语句中，= 右边的值在赋予 = 左边的变量之前，首先要将右边的值的数据类型转换成左边变量的类型。也就是说，左边变量是什么数据类型，右边的值就要转换成什么数据类型的值。这个过程可能导致右边的值的类型升级，也可能导致其类型降级（demotion）。所谓“降级”，是指等级较高的类型被转换成等级较低的类型。

5. 作为参数传递给函数时，char 和 short 会被转换成 int，float 会被转换成 double。使用函数原型可以避免这种自动升级。



### 自动类型转换
自动类型转换就是编译器默默地、隐式地、偷偷地进行的数据类型转换，这种转换不需要程序员干预，会自动发生。

1. 将一种类型的数据赋值给另外一种类型的变量时就会发生自动类型转换，例如：
```
float f = 100;
```
100 是 int 类型的数据，需要先转换为 float 类型才能赋值给变量 f。再如：
```
int n = f;
```
f 是 float 类型的数据，需要先转换为 int 类型才能赋值给变量 n。

在赋值运算中，赋值号两边的数据类型不同时，需要把右边表达式的类型转换为左边变量的类型，这可能会导致数据失真，或者精度降低；所以说，自动类型转换并不一定是安全的。对于不安全的类型转换，编译器一般会给出警告。

2. 在不同类型的混合运算中，编译器也会自动地转换数据类型，将参与运算的所有数据先转换为同一种类型，然后再进行计算。转换的规则如下：
- 转换按数据长度增加的方向进行，以保证数值不失真，或者精度不降低。例如，int 和 long 参与运算时，先把 int 类型的数据转成 long 类型后再进行运算。
- 所有的浮点运算都是以双精度进行的，即使运算中只有 float 类型，也要先转换为 double 类型，才能进行运算。
- char 和 short 参与运算时，必须先转换成 int 类型。

### 强制类型转换
自动类型转换是编译器根据代码的上下文环境自行判断的结果，有时候并不是那么“智能”，不能满足所有的需求。如果需要，程序员也可以自己在代码中明确地提出要进行类型转换，这称为强制类型转换。

自动类型转换是编译器默默地、隐式地进行的一种类型转换，不需要在代码中体现出来；强制类型转换是程序员明确提出的、需要通过特定格式的代码来指明的一种类型转换。换句话说，自动类型转换不需要程序员干预，强制类型转换必须有程序员干预。

强制类型转换的格式为：
`(type_name) expression`
type_name为新类型名称，expression为表达式。例如：
(float) a;  //将变量 a 转换为 float 类型
(int)(x+y);  //把表达式 x+y 的结果转换为 int 整型
(float) 100;  //将数值 100（默认为int类型）转换为 float 类型
下面是一个需要强制类型转换的经典例子：
````c
#include <stdio.h>
int main(){
    int sum = 103;  //总数
    int count = 7;  //数目
    double average;  //平均数
    average = (double) sum / count;
    printf("Average is %lf!\n", average);
    return 0;
}
```
运行结果：
Average is 14.714286!

sum 和 count 都是 int 类型，如果不进行干预，那么sum / count的运算结果也是 int 类型，小数部分将被丢弃；虽然是 average 是 double 类型，可以接收小数部分，但是心有余力不足，小数部分提前就被“阉割”了，它只能接收到整数部分，这就导致除法运算的结果严重失真。

既然 average 是 double 类型，为何不充分利用，尽量提高运算结果的精度呢？为了达到这个目标，我们只要将 sum 或者 count 其中之一转换为 double 类型即可。上面的代码中，我们将 sum 强制转换为 double 类型，这样sum / count的结果也将变成 double 类型，就可以保留小数部分了，average 接收到的值也会更加精确。

在这段代码中，有两点需要注意：
- 对于除法运算，如果除数和被除数都是整数，那么运算结果也是整数，小数部分将被直接丢弃；如果除数和被除数其中有一个是小数，那么运算结果也是小数。这一点已在《C语言加减乘除运算》中进行了详细说明。
- ( )的优先级高于/，对于表达式(double) sum / count，会先执行(double) sum，将 sum 转换为 double 类型，然后再进行除法运算，这样运算结果也是 double 类型，能够保留小数部分。注意不要写作(double) (sum / count)，这样写运算结果将是 3.000000，仍然不能保留小数部分。

### 类型转换只是临时性的

无论是自动类型转换还是强制类型转换，都只是为了本次运算而进行的临时性转换，转换的结果也会保存到临时的内存空间，不会改变数据本来的类型或者值。请看下面的例子：
```
#include <stdio.h>
int main(){
    double total = 400.8;  //总价
    int count = 5;  //数目
    double unit;  //单价
    int total_int = (int)total;
    unit = total / count;
    printf("total=%lf, total_int=%d, unit=%lf\n", total, total_int, unit);
    return 0;
}
```
运行结果：
total=400.800000, total_int=400, unit=80.160000

注意看第 6 行代码，total 变量被转换成了 int 类型才赋值给 total_int 变量，而这种转换并未影响 total 变量本身的类型和值。如果 total 的值变了，那么 total 的输出结果将变为 400.000000；如果 total 的类型变了，那么 unit 的输出结果将变为 80.000000。
自动类型转换 VS 强制类型转换
在C语言中，有些类型既可以自动转换，也可以强制转换，例如 int 到 double，float 到 int 等；而有些类型只能强制转换，不能自动转换，例如以后将要学到的 void * 到 int *，int 到 char * 等。

可以自动转换的类型一定能够强制转换，但是，需要强制转换的类型不一定能够自动转换。现在我们学到的数据类型，既可以自动转换，又可以强制转换，以后我们还会学到一些只能强制转换而不能自动转换的类型。

可以自动进行的类型转换一般风险较低，不会对程序带来严重的后果，例如，int 到 double 没有什么缺点，float 到 int 顶多是数值失真。只能强制进行的类型转换一般风险较高，或者行为匪夷所思，例如，char * 到 int * 就是很奇怪的一种转换，这会导致取得的值也很奇怪，再如，int 到 char * 就是风险极高的一种转换，一般会导致程序崩溃。

使用强制类型转换时，程序员自己要意识到潜在的风险。