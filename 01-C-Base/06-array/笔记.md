


### 1、一维数组

##### 1.1、 一维数组初始化
> 在定义数组的同时进行赋值，称为初始化。全局数组若不初始化，编译器将其初始化为零。局部数组若不初始化，内容为随机值。
```c
int a[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };//定义一个数组，同时初始化所有成员变量
int a[10] = { 1, 2, 3 };//初始化前三个成员，后面所有元素都设置为0
int a[10] = { 0 };//所有的成员都设置为0

//[]中不定义元素个数，定义时必须初始化
int a[] = { 1, 2, 3, 4, 5 };//定义了一个数组，有5个成员

```
##### 1.2、数组名
> 数组名是一个地址的常量，代表数组中首元素的地址。
```c
int a[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };//定义一个数组，同时初始化所有成员变量

printf("a = %p\n", a);
printf("&a[0] = %p\n", &a[0]);
//两个输出值为一样，都是首元素的地址


int n = sizeof(a); //数组占用内存的大小，10个int类型，10 * 4  = 40

int n0 = sizeof(a[0]);//数组第0个元素占用内存大小，第0个元素为int，4

int length = sizeof(a)/sizeof(a[0])
int length = sizeof(a)/sizeof(int)
```

```c
\\数组名array，数组名地址&array，数组名首元素地址&array[0]的区别。

int array[4] ={0}

\\array == &array == &array[0] ==0012FF34

array;   
array + 1; // 0012FF38
&array;  
&array[0] + 1;   //0012FF38
&array + 1;    //0012FF48
sizeof(array) = 20
sizeof(&array) =20
```
- 一般情况下声明一个数组之后，比如int array[5]，数组名array就是数组首元素的首地址，而且是一个地址常量。但是，在函数声明的形参列表中除外。
- 在C中， 在几乎所有使用数组的表达式中，数组名的值是个指针常量，也就是数组第一个元素的地址。 它的类型取决于数组元素的类型： 如果它们是int类型，那么数组名的类型就是“指向int的常量指针“。——《C和指针》
- 在以下两个场合下，数组名并不是用指针常量来表示，就是当数组名作为sizeof操作符和单目操作符&的操作数时。 sizeof返回整个数组的长度，而不是指向数组的指针的长度。 取一个数组名的地址所产生的是一个指向数组的指针，而不是一个指向某个指针常量的指针。所以&a后返回的指针便是指向数组的指针，跟a（一个指向a[0]的指针）在指针的类型上是有区别的。——《C和指针》
- “+1”就是偏移量问题：一个类型为T的指针的移动，是以sizeof(T)为移动单位。 
即array+1：在数组首元素的首地址的基础上，偏移一个sizeof(array[0])单位。此处的类型T就是数组中的一个int型的首元素。由于程序是以16进制表示地址结果，array+1的结果为：0012FF34+1*sizeof(array[0])=0012FF34+1*sizeof(int)=0012FF38。 
即&array+1：在数组的首地址的基础上，偏移一个sizeof(array)单位。此处的类型T就是数组中的一个含有5个int型元素的数组。由于程序是以16进制表示地址结果，&array+1的结果为：0012FF34+1*sizeof(array)=0012FF34+1*sizeof(int)*5=0012FF48。注意1*sizeof(int)*5（等于00000014）要转换成16进制后才能进行相加。
