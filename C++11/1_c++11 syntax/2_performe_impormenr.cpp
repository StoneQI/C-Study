#include<iostream>
#include <type_traits>
#include <typeinfo>
#include <string>
#include <vector>
#include <map>
#include <set>

// 2.1 右值引用
namespace rRef{

// 2.1.1 右值详细介绍
// 在 C++11中，右值由两个概念构成，一个是将亡值（xvalue，expiring value），另一个则是纯右值（prvalue，PureRvalue），比如，非引用返回的临时变量、运算表达式产生的临时变量、原始字面量和lambda表达式等都是纯右值。而将亡值是C++11新增的、与右值引用相关关的表达式，比如，将要被移动的对象、T&&函数返回值、std∶move返回值和转换为T&&的类型的转换函数的返回值。
// C++11中所有的值必属于左值、将亡值、纯右值三者之一9，将亡值和纯右值都属于右值。区分表达式的左右值属性有一个简便方法∶若可对表达式用&符取址，则为左值，否则为右值。
// 比如，简单的赋值语句∶
int i = 0;
// 在这条语句中，i是左值，0是字面量，就是右值。在上面的代码中，i可以被引用，0就不可以了。字面量都是右值。

// 右值引用就是对一个右值进行引用的类型。因为右值不具名，所以我们只能通过引用的方式找到它。
// 无论声明左值引用还是右值引用都必须立即进行初始化，因为引用类型本身并不拥有所绑定对象的内存，只是该对象的一个别名。通过右值引用的声明，该右值又"重获新生"，其生命周期与右值引用类型变量的生命周期一样，只要该变量还活着，该右值临时量将会一直存活下去。

    struct A
    {
        /* data */
    };

    A GetA()
    {
        return A();
    }
    void Test(){
        A a = GetA(); //两次拷贝构造

        A&& b = GetA(); // 通过右值引用，减少一次拷贝构造和析构，通过右值引用绑定了右值，让临时右值的生命周期延长。

        //C++98/03中,用常量左值做性能优化，常量左值是一个“万能”的引用类型，可以接受左值、右值，常量左值、常量右值。注意普通的左值引用不能接受右值。
        const A& a = GetA();

    }

    // 实际上T&&并不是一定表示右值，它绑定的类型是未定的，既可能是左值又可能是右值。（可以认为它是一种未定的引用类型），它必须被初始化，它是左值还是右值引用取决于它的初始化，如果&&被一个左值初始化，它就是一个左值;如果它被一个右值初始化，它就是一个右值。需要注意的是，只有当发生自动类型推断时（如函数模板的类型自动推导，或 auto 关键字），&&才是一个 universal references。
    // 类型折叠规则
    // X& &、X& &&、X&& &都折叠成X&
    // X&& &&折叠为X&&

    template<typename T> 
    void f (T&& param);
    void Test2(){
        f(10);  // 10是右值 
        int x = 10;//× 是左值 f(x)
    }

//    其实还有一条很关键的规则∶ universa references 仅仅在T&&下发生，任何一点附加条件都会使之失效，而变成一个普通的右值引用.因此， T&&在被 const 修饰之后就成为右值引用了。

    void Test3(){
        int a =1;
        auto && a1 = a; // a1 为左值引用
        // int && a2 = a; // erroe 左值不能赋值给右值
        int && a3 = std::move(a); // ok ,move将左值转为右值
    }

// &&的总结如下∶
// 1）左值和右值是独立于它们的类型的，右值引用类型可能是左值也可能是右值。 
// 2）auto&&或函数参数类型自动推导的T&&是一个未定的引用类型，被称为universal references，它可能是左值引用也可能是右值引用类型，取决于初始化的值类型。
// 3）所有的右值引用叠加到右值引用上仍然是一个右值引用，其他引用折叠都为左值引用。当T&&为模板参数时，输入左值，它会变成左值引用，而输入右值时则变为具名的右值引用。
// 4）编译器会将已命名的右值引用视为左值，而将未命名的右值引用视为右值。
void Test3(){
    auto aa =[](int  &&a){ std::cout << a;};
    // auto bb =[aa](int && a) { aa(a);}; //error 此时a为左值。
     auto bb =[aa](int && a) { aa(std::forward<int>(a));};// 完美转发 保持参数的左值，右值特性
    
}

// 2.1.2 右值引用优化性能，避免深拷贝

// 移动构造，避免临时变量构造带来的性能损耗。
// std::move移动对象，原值设为null，不在使用。

}

// 临时变量的存储位置‎这取决于他们的生命周期。在函数内创建的未绑定到本地静态引用以延长其生存期，这很可能是在栈上创建的。绑定到本地静态引用的临时变量很可能存储在程序二进制文件的 .data 部分中。绑定到非本地引用时临时变脸存储位置一样。在非本地变量初始化期间创建的其他临时变量，该变量由引用绑定到的变量应放在生成该非本地变量值的函数栈上。‎在展开期间表示引发对象的异常对象也是临时对象。这些通常位于堆上。‎


// 2.2 move 语义
namespace move{
    
}

// 2.3 forward 语义
namespace move{

    // 右值引用、完美转发再结合可变模板参数，我们可以写一个万能的函数包装器（可变模板参数将在3.2 节中介绍，读者不妨读完下一节再回头来看这个函数），带返回值的、不带返回值的、带参数的和不带参数的函数都可以委托这个万能的函数包装器执行。下面看看这个万能的函数包装器。
    template<class Function, class... Args>
    inline auto FuncWrapper(Function &&f, Args &&...args){
        return f(std::forward<Args>(args)..)
    }


}

// 2.4 emplace_back 就地通过参数构造对象，不需要拷贝或移动内存
namespace emplace_back
{
    
} // namespace emplace_back


// 2.5 unordered_container 无序容器
namespace unordered_container{
    // C++11增加了无序容器unordered_map/unordered multimap和unordered_set/unordered multiset，由于这些容器中的元素是不排序的，因此，比有序容器 map/multimap和set/ multiset效率更高。map和 set 内部是红黑树，在插入元素时会自动排序，而无序容器内部是散列表（Hash Table），通过哈希（Hash），而不是排序来快速操作元素，使得效率更高。由于无序容器内部是散列表，因此无序容器的key 需要提供hash_value 函数，其他用法和 map/set的用法是一样的。不过对于自定义的key，需要提供Hash 函数和比较函数。代码清单2-6是无序容器的基本用法。


}

int main(int argc, char const *argv[])
{
    /* code */
    return 0;
}
